# 更改

## 格式调整

1. 将缩进从原来的2个空格调整至8个空格；
2. 将函数调用后的空格去除；
3. if, while等控制条件间增加了空格；
4. if else语句统一加了大括号，无论是否只有一条语句；
5. 调整了函数声明的格式，使其符合现代C语言的习惯；
6. 调整了指针变量的格式，统一让所有*与变量名贴合在一起；
7. 双目运算符，如+、-、*等，运算符与操作数中间增加空格；
8. typedef struct _export_list后增加空格，并调整了其成员的对齐方式；
9. 移动全局变量和typedef定义到文件上方；

## 逻辑更改

1. 增加struct file_info结构体，用于存储从命令行读入的文件路径信息；
2. 将error函数去除，这个函数的用意不明确，它做了两件事：打印错误信息，释放资源；之后重新设计这个函数；
3. 将main函数逻辑拆开重新组织到几个函数中，并据此去掉部分全局变量；
4. 将函数内部的错误处理更改成 Linux 的goto风格；
5. 重新设计了parse_args的参数，使其接受struct file_info结构体指针，调用后解析命令行参数，将文件名填入file_info结构体；

## TODO

1. 将压缩的逻辑拆开，独立成单独的函数；
2. 向使用压缩逻辑的函数，增加函数指针参数，用来传递压缩函数，从而可以去掉USE_LIBZ宏定义；
3. 向add_export和print_exports函数增加export_list_t*参数，从而让两个函数不必依赖全局变量exports_head，由此将exports_head全局变量变成局部变量；
4. 增加专用于输出错误信息的函数；

## 问题

1. C语言的函数设计中，对于一个需要动态分配内存的逻辑，是否是设计一个专门的函数分配该内存？将分配内存和使用内存的逻辑拆分开？(如Linux的Read函数，buffer是由调用者管理)
   在C++中可以使用返回std::unique_ptr< Resource >的形式表示这个内存由调用者管理，但是在C语言中好像没有这么做的情况？
